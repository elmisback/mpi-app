<canvas id="mpi-canvas" style="width:100%; height:100%">
<script>
  var get_peaks = function(data) {
    // return indices of peaks
    var peaks = [];
    for (var i=0; i < data.length; i++) {
      if (i > 0 && i < data.length - 1 &&
          Math.abs(data[i]) > Math.abs(data[i-1]) &&
          Math.abs(data[i]) > Math.abs(data[i+1])) {
        peaks.push(i);
      }
    }
    return peaks;
  };
  var index_filter = function(A, indices) {
    var B = new Array(indices.length);
    for (var i=0; i < indices.length; i++) {
      B[i] = A[indices[i]];
    }
    return B;
  };

  var order_n_peaks = function(A, n) {
    // Gets the n-th order peak indices
  };

  var chunk_peaks = function(A, chunksize) {
    var peaks = new Array(A.length / chunksize);
    for (var i=0; i * chunksize < A.length; i++) {  //chunk_i
      var max = 0;
      var max_j = 0;
      var start = i * chunksize;
      for (var j=start; (j < start + chunksize) && (j < A.length); j++) {
        if (Math.abs(A[j]) > max) {
          max = Math.abs(A[j]);
          max_j = j;
        }
      }
      peaks[i] = max_j;
    }
    return peaks;
  };

  var interval_color = function(interval) {
    return "Red";
  };

  var paint_intervals = function(intervals) {
    var canvas = document.getElementById("mpi-canvas");
    var ctx = canvas.getContext("2d");
    for (var i=0; i < intervals.length; i++) {
      x1 = canvas.width/n_frames * intervals[i][0];
      x2 = canvas.width/n_frames * intervals[i][1];
      ctx.fillStyle = interval_color(intervals[i]);
      ctx.fillRect(x1, 0, x2 - x1, canvas.height);
      ctx.stroke();
    }
  };

  var phonation_density = function(data) {
    // Yields an array with the density of above-threshold frames.
    var N = 900;  // above-threshold per this many frames.
    var threshold = .15;
    var density = new Array(data.length);
    density.fill(0);

    // NOTE could maybe do this in one pass.

    // Are data entries above threshold?
    var above = new Array(data.length);
    for (var i=0; i < data.length; i++) {
      above[i] = (Math.abs(data[i]) > threshold) ? 1 : 0;
    }

    for (var i=0; i < N; i++) { // get first unit density.
      density[0] += above[i];
    }

    for (var i=N; i < data.length; i++) {
      density[i - N + 1] = density[i - N] + above[i] - above[i - N];
    }
    console.log(density);
    return density;
  };

  var phonation_intervals = function(data) {
    // finds phonation intervals in data based on a threshold
    var density = phonation_density(data);
    console.log(density);
    var intervals = [];
    var curr = null;
    var min_density = 20;
    for (var i=0; i < density.length; i++) {
      var v = density[i];
      if ((!curr) && (v > min_density)) {
          curr = [i, null];
      } else if (curr && (v < min_density)) {
          curr[1] = i - 1;
          intervals.push(curr.slice(0));
          curr = null;
      }
    }
    //console.log(intervals);
    //console.log(intervals.length);
    return intervals;
  }


  var graph = function(data) {
    var canvas = document.getElementById("mpi-canvas");
    // TODO figure out how to scale properly.
    canvas.width=700;
    canvas.height=700;
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var intervals = phonation_intervals(data);
    paint_intervals(intervals);
    ctx.fillStyle= "black";
    var gain = 800;
    //ctx.moveTo(0, canvas.height);
    //ctx.beginPath();
    //var chunksize = 1024;  // Width (in frames) of a chunk.
    //var peaks = chunk_peaks(data, chunksize);
    ////peaks = get_peaks(data);  //indices
    ////peaks_of_peaks = get_peaks(index_filter(data, peaks));
    //for (var i=0; i < peaks.length; i++) {
    //  var j = peaks[i];
    //  var h = canvas.height - Math.abs(data[j] * gain);
    //  var w = j * (canvas.width / data.length);
    //  //ctx.fillRect(w, h, 1, 1);
    //  ctx.lineTo(w, h);
    //}
    var peaks = get_peaks(data);
    for (var i=0; i < peaks.length; i++) {
      var j = peaks[i];
      var h = canvas.height - Math.abs(data[j] * gain);
      var w = j * (canvas.width / data.length);
      ctx.fillRect(w, h, 1, h);
    }
      //ctx.moveTo(w, canvas.height);  // First point (if not origin)
    //ctx.strokeStyle="green"; // Green path
    ctx.stroke();  // Draw it
    //ctx.lineWidth=".5";
  };

  var size = 1024;  // Interval width: number of frames processed on each callback.
  var steps = 45;  // Intervals shown on the screen.
  var n_frames = size * steps;
  var data = new Float32Array(n_frames);
  data.fill(0);
  var handleSuccess = function(stream) {
    console.log('testing!');
    var context = new AudioContext();
    var input = context.createMediaStreamSource(stream)
    var processor = context.createScriptProcessor(size,1,1);
    input.connect(processor);

    console.log(context);
    processor.connect(context.destination);
    /*
    //var steps = 10;
    */

     // console.log('heyo');
    processor.onaudioprocess = function(e){
      // Do something with the data, i.e Convert this to WAV
      samples = e.inputBuffer.getChannelData(0);
      //console.log(samples);
      var i = (steps - 1) * size;
      data.set(data.subarray(size));
      data.set(samples, i);
      //data = data.slice(size).concat(Array.prototype.slice.call(samples));
      graph(data);
    };
  };

  navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleSuccess);
</script>
