<canvas id="mpi-canvas" style="width:100%; height:100%">
<script>
  var get_peaks = function(data) {
    // return indices of peaks
    var peaks = [];
    for (var i=0; i < data.length; i++) {
      if (i > 0 && i < data.length - 1 &&
          Math.abs(data[i]) > Math.abs(data[i-1]) &&
          Math.abs(data[i]) > Math.abs(data[i+1])) {
        peaks.push(i);
      }
    }
    return peaks;
  };
  var index_filter = function(A, indices) {
    var B = new Array(indices.length);
    for (var i=0; i < indices.length; i++) {
      B[i] = A[indices[i]];
    }
    return B;
  };

  var order_n_peaks = function(A, n) {
    // Gets the n-th order peak indices
  };

  var chunk_peaks = function(A, chunksize) {
    var peaks = new Array(A.length / chunksize);
    for (var i=0; i * chunksize < A.length; i++) {  //chunk_i
      var max = 0;
      var max_j = 0;
      var start = i * chunksize;
      for (var j=start; (j < start + chunksize) && (j < A.length); j++) {
        if (Math.abs(A[j]) > max) {
          max = Math.abs(A[j]);
          max_j = j;
        }
      }
      peaks[i] = max_j;
    }
    return peaks;
  };

  var interval_color = function(interval) {
    return "Red";
  };

  var paint_intervals = function(intervals) {
    var canvas = document.getElementById("mpi-canvas");
    var ctx = canvas.getContext("2d");
    for (var i=0; i < intervals.length; i++) {
      x1 = canvas.width/n_frames * intervals[i][0];
      x2 = canvas.width/n_frames * intervals[i][1];
      ctx.fillStyle = interval_color(intervals[i]);
      ctx.fillRect(x1, 0, x2 - x1, canvas.height);
      ctx.stroke();
    }
  };

  var phonation_intervals = function(data) {
    // finds phonation intervals in data based on a threshold
    var intervals = [];
    var curr = null;
    var threshold = .07;
    for (var i=0; i < data.length; i++) {
      var v = Math.abs(data[i]);
      if ((!curr) && (v > threshold)) {
          curr = [i, null];
      } else if (curr && (v < threshold)) {
          curr[1] = i - 1;
          intervals.push(curr.slice(0));
          curr = null;
      }
    }
    console.log(intervals);
    console.log(intervals.length);
    return intervals;
  }


  var graph = function(data) {
    var canvas = document.getElementById("mpi-canvas");
    // TODO figure out how to scale properly.
    canvas.width=700;
    canvas.height=700;
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var intervals = phonation_intervals(data);
    paint_intervals(intervals);
    ctx.fillStyle= "black";
    var gain = 800;
    //ctx.moveTo(0, canvas.height);
    //ctx.beginPath();
    //var chunksize = 1024;  // Width (in frames) of a chunk.
    //var peaks = chunk_peaks(data, chunksize);
    ////peaks = get_peaks(data);  //indices
    ////peaks_of_peaks = get_peaks(index_filter(data, peaks));
    //for (var i=0; i < peaks.length; i++) {
    //  var j = peaks[i];
    //  var h = canvas.height - Math.abs(data[j] * gain);
    //  var w = j * (canvas.width / data.length);
    //  //ctx.fillRect(w, h, 1, 1);
    //  ctx.lineTo(w, h);
    //}
    var peaks = get_peaks(data);
    for (var i=0; i < peaks.length; i++) {
      var j = peaks[i];
      var h = canvas.height - Math.abs(data[j] * gain);
      var w = j * (canvas.width / data.length);
      ctx.fillRect(w, h, 1, h);
    }
      //ctx.moveTo(w, canvas.height);  // First point (if not origin)
    //ctx.strokeStyle="green"; // Green path
    ctx.stroke();  // Draw it
    //ctx.lineWidth=".5";
  };

  var size = 1024;  // Interval width: number of frames processed on each callback.
  var steps = 40;  // Intervals shown on the screen.
  var n_frames = size * steps;
  var data = new Float32Array(n_frames);
  data.fill(0);
  var handleSuccess = function(stream) {
    console.log('testing!');
    var context = new AudioContext();
    var input = context.createMediaStreamSource(stream)
    var processor = context.createScriptProcessor(size,1,1);
    input.connect(processor);

    console.log(context);
    processor.connect(context.destination);
    /*
    //var steps = 10;
    */

     // console.log('heyo');
    processor.onaudioprocess = function(e){
      // Do something with the data, i.e Convert this to WAV
      samples = e.inputBuffer.getChannelData(0);
      //console.log(samples);
      var i = (steps - 1) * size;
      data.set(data.subarray(size));
      data.set(samples, i);
      //data = data.slice(size).concat(Array.prototype.slice.call(samples));
      graph(data);
    };
  };

  navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(handleSuccess);
</script>
